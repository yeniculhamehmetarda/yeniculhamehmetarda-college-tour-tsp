import numpy as np
import random
import math
import time
from dataclasses import dataclass
from typing import List, Tuple
from scipy.spatial import distance # Mesafe hesaplamak için

# ==============================
# 0. PARAMETRELER
# ==============================
N_DAYS = 25               # Gün sayısını biraz makul tuttum
AVG_SPEED = 30_000 / 60   # 30 km/h -> m/dakika
SERVICE_TIME = 120        # 120 dk servis süresi
MAX_DAILY_TIME = 9 * 60   # 9 saat mesai (biraz esnettim çözüm bulsun diye)
MAX_DAILY_DIST = 300_000  # 300 km

# Cezalar
PRIORITY_PENALTY = 10_000
LATE_TIME_PENALTY = 100
TIME_OVER_PENALTY = 200
DIST_OVER_PENALTY = 0.1
BIG_PENALTY = 100_000

# ALNS Ayarları
INITIAL_T = 1000.0
ALPHA_T = 0.95            # Hızlı soğusun diye biraz düşürdüm
MAX_ITER = 2000           # Test için 500 iterasyon yeterli, çok beklemeyelim

# GLOBAL DEĞİŞKENLER
NUM_NODES = 0
DEPOT = 0
DIST_MATRIX = None
time_windows = None
priority = None
daily_time_limits = np.array([MAX_DAILY_TIME] * N_DAYS)
daily_dist_limits = np.array([MAX_DAILY_DIST] * N_DAYS)
MAX_GLOBAL_POSITION_FOR_PRIORITY = 20

# ==============================
# 1. VERİ ÜRETİMİ & YARDIMCI FONKSİYONLAR
# ==============================

def generate_random_instance(n_nodes: int):
    # İstanbul benzeri alan (50km x 30km)
    coords = np.random.rand(n_nodes, 2)
    coords[:, 0] *= 50_000 
    coords[:, 1] *= 30_000 
    
    # Mesafe Matrisi
    dist_matrix = distance.cdist(coords, coords, 'euclidean')
    names = [f"Loc_{i}" if i != 0 else "DEPOT" for i in range(n_nodes)]
    return names, dist_matrix

@dataclass
class Solution:
    routes: List[List[int]]
    cost: float = None
    feasible: bool = False

def build_full_route(day_route: List[int]) -> List[int]:
    return [DEPOT] + day_route + [DEPOT]

def evaluate_solution(sol: Solution) -> Solution:
    penalty = 0.0
    hard_penalty = 0.0
    total_dist = 0.0

    # (A) Visit Counts
    visit_counts = np.zeros(NUM_NODES, dtype=int)
    for r in sol.routes:
        for node in r:
            visit_counts[node] += 1
            
    for i in range(NUM_NODES):
        if i == DEPOT: continue
        if visit_counts[i] == 0:
            penalty += BIG_PENALTY
            hard_penalty += BIG_PENALTY
        elif visit_counts[i] > 1:
            extra = BIG_PENALTY * (visit_counts[i] - 1)
            penalty += extra
            hard_penalty += extra

    # Günlük Kontroller
    for d, route in enumerate(sol.routes):
        full = build_full_route(route)
        day_dist = 0.0
        current_time = 0.0
        
        # Subtour Check (Basit)
        if len(route) != len(set(route)):
            penalty += BIG_PENALTY
            hard_penalty += BIG_PENALTY

        for i in range(len(full) - 1):
            u, v = full[i], full[i+1]
            d_uv = DIST_MATRIX[u, v]
            day_dist += d_uv
            travel_time = d_uv / AVG_SPEED
            current_time += travel_time
            
            # Time Window
            a_i, b_i = time_windows[v]
            if current_time < a_i: current_time = a_i
            current_time += SERVICE_TIME
            if current_time > b_i:
                penalty += (current_time - b_i) * LATE_TIME_PENALTY
        
        total_dist += day_dist
        
        if current_time > daily_time_limits[d]:
            penalty += (current_time - daily_time_limits[d]) * TIME_OVER_PENALTY
        if day_dist > daily_dist_limits[d]:
            penalty += (day_dist - daily_dist_limits[d]) * DIST_OVER_PENALTY

    # Priority Check (Global)
    global_order = []
    for r in sol.routes: global_order.extend(r)
    
    for pos, node in enumerate(global_order):
        if priority[node] == 1 and pos > MAX_GLOBAL_POSITION_FOR_PRIORITY:
            penalty += PRIORITY_PENALTY

    sol.cost = total_dist + penalty
    sol.feasible = (hard_penalty == 0.0)
    return sol

# ==============================
# 2. OPERATÖRLER
# ==============================

def random_removal(sol: Solution, q: int) -> Tuple[Solution, List[int]]:
    routes = [r[:] for r in sol.routes]
    all_nodes = [(d, i, node) for d, r in enumerate(routes) for i, node in enumerate(r)]
    q = min(q, len(all_nodes))
    chosen = random.sample(all_nodes, q)
    removed_nodes = []
    # Sondan başa sil ki indeks kaymasın
    for d, i, node in sorted(chosen, key=lambda x: -x[1]):
        del routes[d][i]
        removed_nodes.append(node)
    return evaluate_solution(Solution(routes=routes)), removed_nodes

def greedy_insert(sol: Solution, request_bank: List[int]) -> Solution:
    # Derin kopyalama simülasyonu (list of lists)
    current_routes = [r[:] for r in sol.routes]
    current_sol = evaluate_solution(Solution(routes=current_routes))
    
    if not request_bank: return current_sol
    random.shuffle(request_bank)

    for u in request_bank:
        best_cost = float('inf')
        best_d, best_pos = None, None
        
        for d in range(N_DAYS):
            r = current_routes[d]
            # Basit bir optimizasyon: Gün çok doluysa deneme
            if len(r) > (NUM_NODES // N_DAYS) + 3: continue 

            for k in range(len(r) + 1):
                r.insert(k, u)
                # Sadece bu halini evaluate et
                cand = evaluate_solution(Solution(routes=current_routes))
                if cand.cost < best_cost:
                    best_cost = cand.cost
                    best_d, best_pos = d, k
                r.pop(k) # Geri al
        
        if best_d is not None:
            current_routes[best_d].insert(best_pos, u)
            current_sol = evaluate_solution(Solution(routes=current_routes))
            
    return current_sol

# ==============================
# 3. ALNS SOLVER
# ==============================

def alns_solver(n_nodes_label):
    # Başlangıç Çözümü
    nodes = list(range(NUM_NODES))
    nodes.remove(DEPOT)
    random.shuffle(nodes)
    routes = [[] for _ in range(N_DAYS)]
    for idx, node in enumerate(nodes):
        routes[idx % N_DAYS].append(node)
    
    S_current = evaluate_solution(Solution(routes=routes))
    S_best = S_current
    T = INITIAL_T
    
    start_time = time.time()
    
    # İlerleme çubuğu gibi çıktı verelim
    print(f"   -> [ALNS Başladı] {n_nodes_label} node için optimizasyon yapılıyor...")
    
    for it in range(MAX_ITER):
        # %20 ila %40 arası sil
        q = random.randint(max(1, NUM_NODES // 5), max(2, NUM_NODES // 2.5))
        
        S_temp, bank = random_removal(S_current, q)
        S_new = greedy_insert(S_temp, bank)
        
        deltaE = S_new.cost - S_current.cost
        if deltaE < 0 or random.random() < math.exp(-deltaE / max(T, 1e-4)):
            S_current = S_new
            if S_new.cost < S_best.cost:
                S_best = S_new
        
        T *= ALPHA_T
        
        # Her 100 iterasyonda bir bilgi ver
        if (it+1) % 100 == 0:
            print(f"      Iter {it+1}/{MAX_ITER} | Best Cost: {S_best.cost:.0f} | Feasible: {S_best.feasible}")
            
    duration = time.time() - start_time
    return S_best, duration

# ==============================
# 4. TEST KOŞUCUSU
# ==============================

def run_sensitivity_test():
    # Test edilecek node sayıları
    test_nodes = [50, 60, 70, 80, 90, 100]
    
    print(f"{'N_NODES':<10} | {'BEST COST':<15} | {'TIME (s)':<10} | {'FEASIBLE':<10}")
    print("-" * 60)

    global NUM_NODES, DIST_MATRIX, UNIV_NAMES, time_windows, priority

    results = []

    for n in test_nodes:
        # Her turda veriyi sıfırla ve yeniden oluştur
        NUM_NODES = n
        UNIV_NAMES, DIST_MATRIX = generate_random_instance(n)
        
        # Time Windows ve Priority Rastgele
        time_windows = np.zeros((n, 2))
        time_windows[:, 0] = 0          
        time_windows[:, 1] = 9 * 60     # 9 saatlik pencere
        
        priority = np.zeros(n, dtype=int)
        prio_indices = np.random.choice(range(1, n), size=int(n*0.2), replace=False)
        priority[prio_indices] = 1
        
        # Çöz
        best_sol, duration = alns_solver(n)
        
        # Sonucu yazdır
        print(f"{n:<10} | {best_sol.cost:<15.1f} | {duration:<10.2f} | {str(best_sol.feasible):<10}")
        results.append((n, best_sol.cost, duration))

    return results

# ==============================
# 5. ANA BLOK (BURASI DÜZELTİLDİ)
# ==============================

if __name__ == "__main__":
    print("=== SENSITIVITY TESTİ BAŞLATILIYOR ===")
    print("Lütfen bekleyin, bu işlem bilgisayar hızına göre 1-3 dakika sürebilir.\n")
    
    run_sensitivity_test()
    
    print("\n=== TEST BAŞARIYLA TAMAMLANDI ===")
